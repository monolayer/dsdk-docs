import{_ as a,c as t,a2 as n,o as s}from"./chunks/framework.DE7eXg1i.js";const m=JSON.parse('{"title":"Function: containerAttach()","description":"","frontmatter":{},"headers":[],"relativePath":"reference/api/v1.47/functions/containerAttach.md","filePath":"reference/api/v1.47/functions/containerAttach.md"}'),i={name:"reference/api/v1.47/functions/containerAttach.md"};function o(c,e,r,d,p,h){return s(),t("div",null,e[0]||(e[0]=[n(`<p><a href="./../../modules.html">dsdk</a> / <a href="./../">v1.47</a> / containerAttach</p><h1 id="function-containerattach" tabindex="-1">Function: containerAttach() <a class="header-anchor" href="#function-containerattach" aria-label="Permalink to &quot;Function: containerAttach()&quot;">​</a></h1><blockquote><p><strong>containerAttach</strong>(<code>opts</code>, <code>callback</code>): <code>void</code></p></blockquote><p>Attach to a container</p><p>Attach to a container to read its output or send it input. You can attach to the same container multiple times and you can reattach to containers that have been detached.</p><p>Either the <code>stream</code> or <code>logs</code> parameter must be <code>true</code> for this endpoint to do anything.</p><p>See the <a href="https://docs.docker.com/engine/reference/commandline/attach/" target="_blank" rel="noreferrer">documentation for the <code>docker attach</code> command</a> for more details.</p><h3 id="hijacking" tabindex="-1">Hijacking <a class="header-anchor" href="#hijacking" aria-label="Permalink to &quot;Hijacking&quot;">​</a></h3><p>This endpoint hijacks the HTTP connection to transport <code>stdin</code>, <code>stdout</code>, and <code>stderr</code> on the same socket.</p><p>This is the response from the daemon for an attach request:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>HTTP/1.1 200 OK</span></span>
<span class="line"><span>Content-Type: application/vnd.docker.raw-stream</span></span>
<span class="line"><span></span></span>
<span class="line"><span>[STREAM]</span></span></code></pre></div><p>After the headers and two new lines, the TCP connection can now be used for raw, bidirectional communication between the client and server.</p><p>To hint potential proxies about connection hijacking, the Docker client can also optionally send connection upgrade headers.</p><p>For example, the client sends this request to upgrade the connection:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>POST /containers/16253994b7c4/attach?stream=1&amp;stdout=1 HTTP/1.1</span></span>
<span class="line"><span>Upgrade: tcp</span></span>
<span class="line"><span>Connection: Upgrade</span></span></code></pre></div><p>The Docker daemon will respond with a <code>101 UPGRADED</code> response, and will similarly follow with the raw stream:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>HTTP/1.1 101 UPGRADED</span></span>
<span class="line"><span>Content-Type: application/vnd.docker.raw-stream</span></span>
<span class="line"><span>Connection: Upgrade</span></span>
<span class="line"><span>Upgrade: tcp</span></span>
<span class="line"><span></span></span>
<span class="line"><span>[STREAM]</span></span></code></pre></div><h3 id="stream-format" tabindex="-1">Stream format <a class="header-anchor" href="#stream-format" aria-label="Permalink to &quot;Stream format&quot;">​</a></h3><p>When the TTY setting is disabled in <a href="#operationcontainercreate"><code>POST /containers/create</code></a>, the HTTP Content-Type header is set to application/vnd.docker.multiplexed-stream and the stream over the hijacked connected is multiplexed to separate out <code>stdout</code> and <code>stderr</code>. The stream consists of a series of frames, each containing a header and a payload.</p><p>The header contains the information which the stream writes (<code>stdout</code> or <code>stderr</code>). It also contains the size of the associated frame encoded in the last four bytes (<code>uint32</code>).</p><p>It is encoded on the first eight bytes like this:</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">header </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{STREAM_TYPE, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, SIZE1, SIZE2, SIZE3, SIZE4}</span></span></code></pre></div><p><code>STREAM_TYPE</code> can be:</p><ul><li>0: <code>stdin</code> (is written on <code>stdout</code>)</li><li>1: <code>stdout</code></li><li>2: <code>stderr</code></li></ul><p><code>SIZE1, SIZE2, SIZE3, SIZE4</code> are the four bytes of the <code>uint32</code> size encoded as big endian.</p><p>Following the header is the payload, which is the specified number of bytes of <code>STREAM_TYPE</code>.</p><p>The simplest way to implement this protocol is the following:</p><ol><li>Read 8 bytes.</li><li>Choose <code>stdout</code> or <code>stderr</code> depending on the first byte.</li><li>Extract the frame size from the last four bytes.</li><li>Read the extracted size and output it on the correct output.</li><li>Goto 1.</li></ol><h3 id="stream-format-when-using-a-tty" tabindex="-1">Stream format when using a TTY <a class="header-anchor" href="#stream-format-when-using-a-tty" aria-label="Permalink to &quot;Stream format when using a TTY&quot;">​</a></h3><p>When the TTY setting is enabled in <a href="#operationcontainercreate"><code>POST /containers/create</code></a>, the stream is not multiplexed. The data exchanged over the hijacked connection is simply the raw data from the process PTY and client&#39;s <code>stdin</code>.</p><h2 id="parameters" tabindex="-1">Parameters <a class="header-anchor" href="#parameters" aria-label="Permalink to &quot;Parameters&quot;">​</a></h2><table><thead><tr><th>Parameter</th><th>Type</th></tr></thead><tbody><tr><td><p><code>opts</code></p></td><td><p><a href="./../type-aliases/ExtendedOptions.html"><code>ExtendedOptions</code></a>&lt;<a href="./../type-aliases/ContainerAttachData.html"><code>ContainerAttachData</code></a>&gt;</p></td></tr><tr><td><p><code>callback</code></p></td><td><p><a href="./../type-aliases/StreamCallbackFn.html"><code>StreamCallbackFn</code></a></p></td></tr></tbody></table><h2 id="returns" tabindex="-1">Returns <a class="header-anchor" href="#returns" aria-label="Permalink to &quot;Returns&quot;">​</a></h2><p><code>void</code></p>`,34)]))}const u=a(i,[["render",o]]);export{m as __pageData,u as default};
