import{_ as t,c as d,a2 as o,o as r}from"./chunks/framework.DE7eXg1i.js";const m=JSON.parse('{"title":"Type Alias: ImageBuildData","description":"","frontmatter":{},"headers":[],"relativePath":"reference/api/v1.47/type-aliases/ImageBuildData.md","filePath":"reference/api/v1.47/type-aliases/ImageBuildData.md"}'),a={name:"reference/api/v1.47/type-aliases/ImageBuildData.md"};function c(i,e,s,n,u,l){return r(),d("div",null,e[0]||(e[0]=[o('<p><a href="./../../modules.html">dsdk</a> / <a href="./../">v1.47</a> / ImageBuildData</p><h1 id="type-alias-imagebuilddata" tabindex="-1">Type Alias: ImageBuildData <a class="header-anchor" href="#type-alias-imagebuilddata" aria-label="Permalink to &quot;Type Alias: ImageBuildData&quot;">​</a></h1><blockquote><p><strong>ImageBuildData</strong>: <code>object</code></p></blockquote><h2 id="type-declaration" tabindex="-1">Type declaration <a class="header-anchor" href="#type-declaration" aria-label="Permalink to &quot;Type declaration&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>headers</code>?</td><td><code>object</code></td><td>-</td></tr><tr><td><code>headers.Content-type</code>?</td><td><code>&quot;application/x-tar&quot;</code></td><td>-</td></tr><tr><td><code>headers.X-Registry-Config</code>?</td><td><code>string</code></td><td>This is a base64-encoded JSON object with auth configurations for multiple registries that a build may refer to. The key is a registry URL, and the value is an auth configuration object, <a href="#sectionauthentication">as described in the authentication section</a>. For example: <code>{ &quot;docker.example.com&quot;: { &quot;username&quot;: &quot;janedoe&quot;, &quot;password&quot;: &quot;hunter2&quot; }, &quot;https://index.docker.io/v1/&quot;: { &quot;username&quot;: &quot;mobydock&quot;, &quot;password&quot;: &quot;conta1n3rize14&quot; } }</code> Only the registry domain name (and port if not the default 443) are required. However, for legacy reasons, the Docker Hub registry must be specified with both a <code>https://</code> prefix and a <code>/v1/</code> suffix even though Docker will prefer to use the v2 registry API.</td></tr><tr><td><code>query</code>?</td><td><code>object</code></td><td>-</td></tr><tr><td><code>query.buildargs</code>?</td><td><code>string</code></td><td>JSON map of string pairs for build-time variables. Users pass these values at build-time. Docker uses the buildargs as the environment context for commands run via the <code>Dockerfile</code> RUN instruction, or for variable expansion in other <code>Dockerfile</code> instructions. This is not meant for passing secret values. For example, the build arg <code>FOO=bar</code> would become <code>{&quot;FOO&quot;:&quot;bar&quot;}</code> in JSON. This would result in the query parameter <code>buildargs={&quot;FOO&quot;:&quot;bar&quot;}</code>. Note that <code>{&quot;FOO&quot;:&quot;bar&quot;}</code> should be URI component encoded. <a href="https://docs.docker.com/engine/reference/builder/#arg" target="_blank" rel="noreferrer">Read more about the buildargs instruction.</a></td></tr><tr><td><code>query.cachefrom</code>?</td><td><code>string</code></td><td>JSON array of images used for build cache resolution.</td></tr><tr><td><code>query.cpuperiod</code>?</td><td><code>number</code></td><td>The length of a CPU period in microseconds.</td></tr><tr><td><code>query.cpuquota</code>?</td><td><code>number</code></td><td>Microseconds of CPU time that the container can get in a CPU period.</td></tr><tr><td><code>query.cpusetcpus</code>?</td><td><code>string</code></td><td>CPUs in which to allow execution (e.g., <code>0-3</code>, <code>0,1</code>).</td></tr><tr><td><code>query.cpushares</code>?</td><td><code>number</code></td><td>CPU shares (relative weight).</td></tr><tr><td><code>query.dockerfile</code>?</td><td><code>string</code></td><td>Path within the build context to the <code>Dockerfile</code>. This is ignored if <code>remote</code> is specified and points to an external <code>Dockerfile</code>.</td></tr><tr><td><code>query.extrahosts</code>?</td><td><code>string</code></td><td>Extra hosts to add to /etc/hosts</td></tr><tr><td><code>query.forcerm</code>?</td><td><code>boolean</code></td><td>Always remove intermediate containers, even upon failure.</td></tr><tr><td><code>query.labels</code>?</td><td><code>string</code></td><td>Arbitrary key/value labels to set on the image, as a JSON map of string pairs.</td></tr><tr><td><code>query.memory</code>?</td><td><code>number</code></td><td>Set memory limit for build.</td></tr><tr><td><code>query.memswap</code>?</td><td><code>number</code></td><td>Total memory (memory + swap). Set as <code>-1</code> to disable swap.</td></tr><tr><td><code>query.networkmode</code>?</td><td><code>string</code></td><td>Sets the networking mode for the run commands during build. Supported standard values are: <code>bridge</code>, <code>host</code>, <code>none</code>, and `container:&lt;name</td></tr><tr><td><code>query.nocache</code>?</td><td><code>boolean</code></td><td>Do not use the cache when building the image.</td></tr><tr><td><code>query.outputs</code>?</td><td><code>string</code></td><td>BuildKit output configuration</td></tr><tr><td><code>query.platform</code>?</td><td><code>string</code></td><td>Platform in the format os[/arch[/variant]]</td></tr><tr><td><code>query.pull</code>?</td><td><code>string</code></td><td>Attempt to pull the image even if an older image exists locally.</td></tr><tr><td><code>query.q</code>?</td><td><code>boolean</code></td><td>Suppress verbose build output.</td></tr><tr><td><code>query.remote</code>?</td><td><code>string</code></td><td>A Git repository URI or HTTP/HTTPS context URI. If the URI points to a single text file, the file’s contents are placed into a file called <code>Dockerfile</code> and the image is built from that file. If the URI points to a tarball, the file is downloaded by the daemon and the contents therein used as the context for the build. If the URI points to a tarball and the <code>dockerfile</code> parameter is also specified, there must be a file with the corresponding path inside the tarball.</td></tr><tr><td><code>query.rm</code>?</td><td><code>boolean</code></td><td>Remove intermediate containers after a successful build.</td></tr><tr><td><code>query.shmsize</code>?</td><td><code>number</code></td><td>Size of <code>/dev/shm</code> in bytes. The size must be greater than 0. If omitted the system uses 64MB.</td></tr><tr><td><code>query.squash</code>?</td><td><code>boolean</code></td><td>Squash the resulting images layers into a single layer. <em>(Experimental release only.)</em></td></tr><tr><td><code>query.t</code>?</td><td><code>string</code></td><td>A name and optional tag to apply to the image in the <code>name:tag</code> format. If you omit the tag the default <code>latest</code> value is assumed. You can provide several <code>t</code> parameters.</td></tr><tr><td><code>query.target</code>?</td><td><code>string</code></td><td>Target build stage</td></tr><tr><td><code>query.version</code>?</td><td><code>&quot;1&quot;</code> | <code>&quot;2&quot;</code></td><td>Version of the builder backend to use. - <code>1</code> is the first generation classic (deprecated) builder in the Docker daemon (default) - <code>2</code> is <a href="https://github.com/moby/buildkit" target="_blank" rel="noreferrer">BuildKit</a></td></tr></tbody></table>',5)]))}const p=t(a,[["render",c]]);export{m as __pageData,p as default};
